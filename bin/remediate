#! /usr/bin/env ruby

# This action is used to remediate objects in some way that you define.
# You supply a list of druids to remediate in a CSV file and a Ruby file defining a method that operates on the objects.
# The code handles all logging and versioning as needed.

# Run with
# ROBOT_ENVIRONMENT=production bin/remediate INPUT_FILE.csv REMEDIATE_LOGIC_FILENAME.rb

# eg. ROBOT_ENVIRONMENT=production bin/remediate /dor/preassembly/remediation/revs_all_pids.csv /dor/preassembly/remediation/scripts/revs_rights_remediate.rb

# Add in optional parameters to override defaults for checking if items are in accessioning or if they require versioning and set to false.
# Only do this if you are sure you know what you are doing for scripts that for some reason will not work with versioning!

# ROBOT_ENVIRONMENT=production bin/remediate INPUT_FILE.csv REMEDIATE_LOGIC_FILENAME.rb ignore_versioning ignore_accessioning

# INPUT_FILE can be either a pre-assembly generated YAML log file or a CSV file with one column containing at least a list of druids
# If a pre-assembly YAML log file is passed in, the successfully accessioned druids will be used.
# For a CSV file, there should be a header with a column labeled "druid" which indicates which column contains the druid
# This file should be in a location where the script has read/write access to it.

# e.g.
#druid,another_column
#druid:oo000oo0001,other stuff
#druid:oo000oo0002,ignored

# REMEDIATE_LOGIC_FILENAME is a reference to a Ruby code file that defines what you want the remediation to do.  An example of this
# file is in lib/remediation/remediate_project_example.rb  Copy that file, and edit it somewhere the script can read it and then pass
# the filename to the script.

# The result will be some screen output, a detailed .YML file in the same location and with the same name as the input CSV file.
# The input CSV file will be updated with two additional columns - a status indicating if remediation succeeded and a message.
# You can re-run remediation with the same CSV file and it will automatically skip already completed objects.

# Note that unless your laptop has access to the Fedora instance you need to remediate (usually Production),
# you should probably run this from lyberservices-prod to have access to all mounts and configuration.

require File.expand_path(File.dirname(__FILE__) + '/../config/boot')
require 'rubygems'
require 'csv'
require 'csv-mapper'

def help(error_msg)
  abort "#{error_msg}\n\nUsage:\n  ROBOT_ENVIRONMENT=XXXXX remediate INPUT_FILE REMEDIATE_LOGIC_FILENAME\n"
end

help "Incorrect N of arguments." if ARGV.size < 2
input_file = ARGV[0]
remediate_logic_file = ARGV[1]

ignore_accessioning = true if ARGV.include? 'ignore_accessioning' # override config file if supplied
ignore_versioning = true if ARGV.include? 'ignore_versioning'  # override config file if supplied

help "Input file not found." unless File.file?(input_file)
help "REMEDIATE_LOGIC_FILE file not found." unless File.file?(remediate_logic_file)

require remediate_logic_file

if ignore_accessioning
  puts "*** OVERRIDING CONFIG: Ignoring accessioning check"
  Dor::Config.remediation.check_for_in_accessioning = false
end
if ignore_versioning
  puts "*** OVERRIDING CONFIG: Ignoring versioning check"
  Dor::Config.remediation.check_for_versioning_required = false
end

source_path=File.dirname(input_file)
source_ext=File.extname(input_file)
source_name=File.basename(input_file,source_ext)

help "Input file not a CSV or YAML/YML file." unless ['.csv','.yml','.yaml'].include? source_ext.downcase

progress_log_file=File.join(source_path,source_name + '_log.yml')
csv_out=File.join(source_path, source_name + "_log.csv")

# read in completed druids so we don't reprocess them
completed_druids=PreAssembly::Remediation::Item.get_druids(progress_log_file)

# read input druids
if source_ext.downcase == '.csv' # read from CSV file
  rows=CsvMapper.import(input_file){read_attributes_from_file}
  druids=rows.collect{|row| row.druid.include?("druid:") ? row.druid : "druid:#{row.druid}"} # add the druid prefix if missing from input file
else # this must be a YAML progress log file
  druids=Assembly::Utils.get_druids_from_log(input_file,true)
end

total_druids=druids.size
total_completed=completed_druids.size
total_to_process=total_druids-total_completed

puts "Input file: #{input_file}"
puts "Found #{total_to_process} to remediate.  Total in file: #{total_druids}.  Already completed: #{total_completed}"
puts "Started at #{Time.now}"
puts ""
$stdout.flush

start_time=Time.now
total_success=0
total_failure=0
count=0
avg_time_per_object=0
total_time_remaining=0

druids.each do |druid|
  done=completed_druids.include?(druid)
  unless done
    count+=1
    item=PreAssembly::Remediation::Item.new(druid)
    item.description=File.basename(remediate_logic_file) # added to the version description
    item.extend(RemediationLogic) # add in our project specific methods
    success=item.remediate
    if success
      total_success += 1
      result="success"
    else
      result="FAILURE"
      total_failure += 1
    end
    total_time=Time.now-start_time

    remaining_to_process=total_to_process-count
    avg_time_per_object=total_time/count
    total_time_remaining=(avg_time_per_object * remaining_to_process).floor

    status = "#{druid} : #{result} : #{count} of #{total_to_process} (#{remaining_to_process} remaining) : #{Time.now} : ~#{PreAssembly::Logging.seconds_to_string(total_time_remaining)} left"
    item.log_to_progress_file(progress_log_file)
    item.log_to_csv(csv_out)
    puts status
    $stdout.flush
  end
end

end_time=Time.now
total_time=((end_time-start_time) / 1.hour).round(2)

puts ""
puts "Input file: #{input_file}"
puts "Output file: #{csv_out}"
puts "Ended at #{end_time}.  Total time: #{total_time} hours.  Average time per object: #{(total_time*3600/total_to_process).round(2)} seconds"
puts "Total in file: #{total_druids}. Total processed: #{total_to_process}. Successful: #{total_success}. Completed previously: #{total_completed}.  Failed: #{total_failure}"

$stdout.flush
